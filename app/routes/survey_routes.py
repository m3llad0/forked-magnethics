from flask import request, jsonify, Blueprint, current_app, g
from app.utils import logger
from app.services import db
from app.models import EmployeeSurveyAssignment
from app.services.assignment_service import AssignmentService
from app.services.survey_service import SurveyService
from app.middleware import token_required, postman_consultant_token_required
import pandas as pd
from io import BytesIO

survey = Blueprint("survey", __name__)

@survey.route("/", methods=["POST"])
def create_survey():
    """
    Create a new survey.

    Expected JSON Body:
        {
            "id": "unique_survey_id",           # Unique identifier for the survey.
            "title": "Survey Title",            # Title of the survey.
            "subtitle": "Survey Subtitle",      # Subtitle or brief description.
            "description": "Detailed description...",  # Full description of the survey.
            "client_id": "client_id_string",    # ID of the client (organization) from SQL.
            "product_id": "product_id_string",  # ID of the product associated with the survey (SQL).
            "deadline": "YYYY-MM-DD",           # Deadline date for the survey (ISO format).
            "handInDate": "YYYY-MM-DD",         # Hand-in date for the survey (ISO format).
            "scale_ids": "scale_id_string" OR ["scale_id1", "scale_id2"],
                                                # Either a single scale ID (string) or a list of scale IDs.
            "stage_ids": ["stage_id1", "stage_id2"],  # Array of stage IDs to fetch all questions from.
            "survey_type": "360" or "enex"        # Type of survey; determines how scales are applied.
        }

    Returns:
        JSON response containing a success message and the created survey_id.
    """
    try:
        data = request.json
        survey_service = SurveyService(current_app.mongo_db, db)
        survey_id = survey_service.create_survey(data)
        return jsonify({"message": "Created new survey", "survey_id": survey_id}), 201
    except ValueError as ve:
        return jsonify({"error": str(ve)}), 400
    except Exception as e:
        logger.critical("Error creating survey", exc_info=e)
        return jsonify({"error": "Internal Server Error"}), 500

@survey.route("/assign/<survey_id>/<client_id>", methods=["GET"])
# @postman_consultant_token_required
def generate_assignment_excel(survey_id, client_id):
    """Generate an organization chart Excel file.

    Query Parameters:
        client_id (str): ID of the client for which to fetch employees.

    Returns:
        An Excel file (as a downloadable attachment) containing:
            - Employee details: employee_id, employee_number, first_name, last_name, email, position.
            - Direct and functional supervisor names.
            - Survey details: survey_id, survey_type.
            - Default assignment fields:
                * For ENEX surveys: target_employee_id is None, target_type is "company".
                * For 360 surveys: target_employee_id is blank (to be filled manually), target_type is "employee".
    """
    try:
        # client_id = request.args.get("client_id")
        if not client_id:
            return jsonify({"error": "Client ID is required"}), 400
        
        assignment_service = AssignmentService(db)
        excel_file = assignment_service.generate_assignment_excel(survey_id, client_id)
        return current_app.response_class(
            excel_file,
            mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            headers={"Content-Disposition": f"attachment; filename=organization_chart_{survey_id}.xlsx"}
        )
    except ValueError as ve:
        return jsonify({"error": str(ve)}), 400
    except Exception as e:
        current_app.logger.error("Error generating assignment Excel", exc_info=e)
        return jsonify({"error": "Internal Server Error"}), 500

@survey.route("/assign/upload", methods=["POST"])
@postman_consultant_token_required
def finalize_assignment():
    """
    Finalize survey assignments.

    Expected Request:
        Multipart/form-data with a file attached under the key "file".
        The uploaded Excel file should have columns matching those generated by the GET /assign/<survey_id> endpoint.

    Returns:
        JSON response with a success message and a list of finalized assignment records.
    """
    try:
        if "file" not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
        file = request.files["file"]
        if file.filename == "":
            return jsonify({"error": "No selected file"}), 400
        
        # Read the uploaded Excel file into a DataFrame.
        df = pd.read_excel(file)
        print(df)
        assignment_service = AssignmentService(db)
        assignments = assignment_service.finalize_assignment(df)
        return jsonify({"message": "Survey assignments finalized", "assignments": assignments}), 200
    except Exception as e:
        current_app.logger.critical("Error finalizing assignments", exc_info=e)
        db.session.rollback()
        return jsonify({"error": "Internal Server Error"}), 500

@survey.route("/<id>", methods=["GET"])
def get_survey(id):
    """
        Retrieve a survey.

    Path Parameter:
        id (str): The unique identifier of the survey.

    Returns:
        JSON representation of the survey document from MongoDB.
    """
    try:
        db_mongo = current_app.mongo_db
        if not db_mongo:
            return jsonify({"error": "Database not initialized"}), 500

        surveys_collection = db_mongo.get_collection("Surveys")
        survey_doc = surveys_collection.find_one({"_id": id})
        if not survey_doc:
            return jsonify({"message": "Survey not found"}), 404

        return jsonify(survey_doc), 200
    except Exception as e:
        logger.critical("Error getting survey", exc_info=e)
        return jsonify({"error": "Internal Server Error"}), 500


@survey.route("/<id>", methods=["PUT"])
def update_survey(id):
    """"    
    Update an existing survey.

    Path Parameter:
        id (str): The unique identifier of the survey.

    Expected JSON Body:
        A JSON object containing the fields to update (e.g., title, subtitle, deadline, etc.).

    Returns:
        A success message if the update was performed.
    """
    try:
        update_data = request.json

        if not update_data:
            logger.error("No update data provided")
            return jsonify({"error": "No update data provided"}), 400

        db_mongo = current_app.mongo_db
        if not db_mongo:
            return jsonify({"error": "Database not initialized"}), 500

        surveys_collection = db_mongo.get_collection("Surveys")
        result = surveys_collection.update_one({"id": id}, {"$set": update_data})
        if result.modified_count == 0:
            return jsonify({"message": "No data updated. Survey may not exist."}), 404

        return jsonify({"message": "Survey updated successfully."}), 200
    except Exception as e:
        logger.critical("Error updating survey", exc_info=e)
        return jsonify({"error": "Internal Server Error"}), 500

@survey.route("/<id>", methods=["DELETE"])
def delete_survey(id):
    """
       Delete a survey.

    Path Parameter:
        id (str): The unique identifier of the survey.

    Returns:
        A success message if the survey was deleted, or an error message if not found.
    """
    try:
        db_mongo = current_app.mongo_db
        if not db_mongo:
            return jsonify({"error": "Database not initialized"}), 500

        surveys_collection = db_mongo.get_collection("Surveys")
        result = surveys_collection.delete_one({"id": id})
        if result.deleted_count == 0:
            return jsonify({"message": "No data deleted. Survey may not exist."}), 404

        return jsonify({"message": "Survey deleted successfully."}), 200
    except Exception as e:
        logger.critical("Error deleting survey", exc_info=e)
        return jsonify({"error": "Internal Server Error"}), 500
